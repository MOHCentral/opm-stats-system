// ============================================================================
// OpenMOHAA Telemetry Tracker - Common Helpers v2.0
// ============================================================================

// ============================================================================
// CONFIGURATION & GLOBALS
// ============================================================================
level.api_base_url = "http://localhost:8080"
    level.api_events_endpoint = "/api/v1/ingest/events"
    level.server_token = "dev-server-token-replace-in-production"
    level.server_id = "dev-server-01"
    level.tracker_debug = 1

    // Batching Globals
    level.event_queue = ""
    level.batch_size = 0
    level.max_batch_size = 20 // Flush immediately if this size reached

    // ============================================================================
    // PLAYER PAYLOAD BUILDER
    // ============================================================================
build_player_payload local.player local.prefix:
        local.payload = ""

        if (local.player == NIL || local.player.netname == NIL) {
            end local.payload
        }

        local.guid = ""
        // PRIORITIZE PERSISTENT IDENTITY
        if (local.player.is_authenticated == 1 && local.player.smf_member_id != NIL && local.player.smf_member_id > 0) {
            local.guid = local.player.smf_member_id
        } else {
            // Fallback for unauthenticated players: "clientnum" is not persistent, but "name" is spoofable.
            // We use clientnum for unique match tracking.
            local.guid = "unauth_" + (getclientnum local.player)
        }

        // Core Identity
        local.payload = "&" + local.prefix + "_name=" + local.player.netname
        local.payload = local.payload + "&" + local.prefix + "_guid=" + local.guid

        // SMF Identity (Explicit field)
        if (local.player.is_authenticated == 1 && local.player.smf_member_id != NIL) {
            local.payload = local.payload + "&" + local.prefix + "_smf_id=" + local.player.smf_member_id
        }

        // Team
        if (local.player.team != NIL && local.player.team != "") {
            local.payload = local.payload + "&" + local.prefix + "_team=" + local.player.team
        }

        // Location
        if (local.player.origin != NIL) {
            local.pos = local.player.origin
            local.payload = local.payload + "&" + local.prefix + "_x=" + local.pos[0]
            local.payload = local.payload + "&" + local.prefix + "_y=" + local.pos[1]
            local.payload = local.payload + "&" + local.prefix + "_z=" + local.pos[2]
        }

        // Angles
        if (local.player.angles != NIL) {
            local.ang = local.player.angles
            local.payload = local.payload + "&" + local.prefix + "_pitch=" + local.ang[0]
            local.payload = local.payload + "&" + local.prefix + "_yaw=" + local.ang[1]
        }

        end local.payload

build_player_payload_compact local.player local.prefix:
            local.payload = ""

            if (local.player == NIL || local.player.netname == NIL) {
                end local.payload
            }

            local.guid = ""
            if (local.player.is_authenticated == 1 && local.player.smf_member_id != NIL && local.player.smf_member_id > 0) {
                local.guid = local.player.smf_member_id
            } else {
                local.guid = "unauth_" + (getclientnum local.player)
            }

            local.payload = "&" + local.prefix + "_name=" + local.player.netname
            local.payload = local.payload + "&" + local.prefix + "_guid=" + local.guid

            if (local.player.is_authenticated == 1 && local.player.smf_member_id != NIL) {
                local.payload = local.payload + "&" + local.prefix + "_smf_id=" + local.player.smf_member_id
            }

            if (local.player.team != NIL && local.player.team != "") {
                local.payload = local.payload + "&" + local.prefix + "_team=" + local.player.team
            }

            end local.payload

            // ============================================================================
            // BATCHING SYSTEM
            // ============================================================================

queue_event local.payload:
            // Append server identification to each event
                local.full_payload = local.payload + "&server_token=" + level.server_token
                local.full_payload = local.full_payload + "&server_id=" + level.server_id

                if (level.event_queue == "") {
                    level.event_queue = local.full_payload
                } else {
                    level.event_queue = level.event_queue + "\n" + local.full_payload
                }
    
                level.batch_size++
    
                if (level.batch_size >= level.max_batch_size) {
                    thread flush_queue
                }
            end

flush_queue:
                if (level.event_queue == "") {
                    end
                }

                local.payload_to_send = level.event_queue
                level.event_queue = ""
                level.batch_size = 0

                local.url = level.api_base_url + level.api_events_endpoint
    
                if (level.tracker_debug) {
                    println ("API BATCH FLUSH: " + local.url)
                }
    
                curl_post local.url local.payload_to_send "tracker_common.scr::on_http_callback"
            end

flush_loop:
                while (1) {
                    wait 2
                    thread flush_queue
                }
            end

            // Deprecated - kept for compatibility
send_to_api local.payload:
                thread queue_event local.payload
            end

            // ============================================================================
            // HELPERS
            // ============================================================================

on_http_callback local.success local.response local.http_code:
                if (level.tracker_debug) {
                    if (local.success) {
                        println ("HTTP OK [" + local.http_code + "]")
                    } else {
                        println ("HTTP FAIL [" + local.http_code + "]: " + local.response)
                    }
                }
            end

build_base_payload local.event_type:
                local.payload = "type=" + local.event_type
                local.payload = local.payload + "&match_id=" + level.match_id
                local.payload = local.payload + "&timestamp=" + level.time
    
                if (level.session_id != NIL && level.session_id != "") {
                    local.payload = local.payload + "&session_id=" + level.session_id
                }
    
                if (level.map_name != NIL && level.map_name != "") {
                    local.payload = local.payload + "&map_name=" + level.map_name
                }
    
                end local.payload

debug_log local.message:
                    if (level.tracker_debug) {
                        println ("[TRACKER] " + local.message)
                    }
                end

                // ============================================================================
                // STRING HELPERS
                // ============================================================================
                // Returns the index of 'search' within 'str', starting from 'start'
str_indexof local.str local.search local.start:
                    if (local.start == NIL) local.start = 0
                        if (local.str == NIL || local.search == NIL) end -1
    
                            local.str_len = local.str.size
                    local.search_len = local.search.size
    
                    if (local.search_len == 0) end local.start
                        if (local.search_len > local.str_len) end -1
    
                            for (local.i = local.start; local.i <= (local.str_len - local.search_len); local.i++) {
                        local.found = 1
                        for (local.j = 0; local.j < local.search_len; local.j++) {
                            if (local.str[local.i + local.j] != local.search[local.j]) {
                                local.found = 0
                                break
                            }
                        }
                        if (local.found) end local.i
                    }
                    end -1

                    // ============================================================================
                    // JSON HELPERS (Basic Parsing)
                    // ============================================================================
                    // Extracts a string value from a simple JSON object: {"key":"value"}
json_get_string local.json local.key:
                        local.quote = (char 34)
                        local.key_quoted = local.quote + local.key + local.quote
                        local.key_index = waitthread str_indexof local.json local.key_quoted
                        if (local.key_index == -1) end ""
    
                            // Find colon after key
                        local.colon_index = waitthread str_indexof local.json ":" (local.key_index + local.key_quoted.size)
                        if (local.colon_index == -1) end ""
    
                            // Find first quote after colon
                        local.start_quote = waitthread str_indexof local.json local.quote (local.colon_index + 1)
                        if (local.start_quote == -1) end ""
    
                            // Find end quote
                        local.end_quote = waitthread str_indexof local.json local.quote (local.start_quote + 1)
                        if (local.end_quote == -1) end ""
    
                            local.result = ""
                        for (local.i = (local.start_quote + 1); local.i < local.end_quote; local.i++) {
                            local.result = local.result + local.json[local.i]
                        }
                        end local.result

                        // Extracts an integer value from a simple JSON object: {"key":123}
json_get_int local.json local.key:
                            local.quote = (char 34)
                            local.key_quoted = local.quote + local.key + local.quote
                            local.key_index = waitthread str_indexof local.json local.key_quoted
                            if (local.key_index == -1) end 0
    
                                // Find colon after key
                            local.colon_index = waitthread str_indexof local.json ":" (local.key_index + local.key_quoted.size)
                            if (local.colon_index == -1) end 0
    
                                // Start after colon, skip spaces
                            local.start = local.colon_index + 1
                            while (local.start < local.json.size && (local.json[local.start] == " " || local.json[local.start] == "\t")) {
                                local.start++
                            }
    
                            local.result_str = ""
                            local.i = local.start
                            while (local.i < local.json.size) {
                                local.char = local.json[local.i]
                                if (local.char >= "0" && local.char <= "9") {
                                    local.result_str = local.result_str + local.char
                                } else if (local.char == "-" && local.result_str == "") {
                                    local.result_str = local.result_str + local.char
                                } else {
                                    break
                                }
                                local.i++
                            }
    
                            if (local.result_str == "") end 0
                                end (int local.result_str)
