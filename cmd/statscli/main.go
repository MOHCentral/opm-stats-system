package statscli










































































































































































































































































































































































































































































































































































































































































































































































































































































































































}	}		os.Exit(1)		printUsage()		fmt.Printf("Unknown command: %s\n", os.Args[1])	default:				printUsage()	case "help", "-h", "--help":				cmdStatus()	case "status":				cmdClear()	case "clear":				cmdSeed(numMatches)		}			fmt.Sscanf(os.Args[2], "%d", &numMatches)		if len(os.Args) > 2 {		numMatches := 100	case "seed":	switch os.Args[1] {		}		os.Exit(1)		printUsage()	if len(os.Args) < 2 {		rand.Seed(time.Now().UnixNano())func main() {}	}		fmt.Printf("API Server: âœ“ Healthy\n")		defer resp.Body.Close()	} else {		fmt.Printf("API Server: âŒ Not reachable\n")	if err != nil {	resp, err = client.Get("http://localhost:8080/health")	// Check API		}		}			fmt.Printf("PostgreSQL: âœ“ Connected\n")		} else {			fmt.Printf("PostgreSQL: âŒ Ping failed: %v\n", err)		if err := db.Ping(); err != nil {		defer db.Close()	} else {		fmt.Printf("PostgreSQL: âŒ Connection error: %v\n", err)	if err != nil {	db, err := sql.Open("postgres", PostgresURL)	// Check PostgreSQL		}		fmt.Printf("ClickHouse: âœ“ Connected (%s events)\n", bytes.TrimSpace(buf.Bytes()))		buf.ReadFrom(resp.Body)		var buf bytes.Buffer		defer resp.Body.Close()	} else {		fmt.Printf("ClickHouse: âŒ Not reachable\n")	if err != nil {	resp, err := client.Get(ClickHouseURL + "/?query=SELECT%20count()%20FROM%20raw_events")	client := &http.Client{Timeout: 5 * time.Second}	// Check ClickHouse		fmt.Println("ðŸ“Š Database Status\n")func cmdStatus() {}	fmt.Println("\nâœ“ Clear complete!")		}		fmt.Printf("  Error: %v\n", err)	if err := clearRedis(); err != nil {	fmt.Println("\nClearing Redis...")		}		fmt.Printf("  Error: %v\n", err)	if err := clearPostgres(); err != nil {	fmt.Println("\nClearing PostgreSQL...")		}		fmt.Printf("  Error: %v\n", err)	if err := clearClickHouse(); err != nil {	fmt.Println("Clearing ClickHouse...")		fmt.Println("ðŸ§¹ Clearing all test data...\n")func cmdClear() {}	stats.Print()		done <- true	wg.Wait()		}		}()			}				sim.Run()				sim := NewMatchSimulator(client, stats)			for range matchChan {			defer wg.Done()		go func() {		wg.Add(1)	for i := 0; i < Concurrency; i++ {	// Start workers		close(matchChan)	}		matchChan <- i	for i := 0; i < numMatches; i++ {	// Fill channel with match indices		matchChan := make(chan int, numMatches)	var wg sync.WaitGroup	// Run matches in parallel		}()		}			}				return			case <-done:				fmt.Printf("\r  Progress: %d/%d matches, %d events...", matches, numMatches, events)				matches := atomic.LoadInt64(&stats.matchesRun)				events := atomic.LoadInt64(&stats.eventsSent)			case <-ticker.C:			select {		for {		defer ticker.Stop()		ticker := time.NewTicker(2 * time.Second)	go func() {	done := make(chan bool)	// Progress ticker		client := &http.Client{Timeout: 5 * time.Second}	stats := &Stats{startTime: time.Now()}		fmt.Printf("ðŸš€ Seeding %d matches across %d servers...\n\n", numMatches, len(servers))func cmdSeed(numMatches int) {}`)  CLICKHOUSE_URL   ClickHouse HTTP endpoint  POSTGRES_URL     PostgreSQL connection string  API_URL          API endpoint (default: http://localhost:8080/api/v1/ingest/events)Environment:  statscli clear         # Clear all data  statscli seed 500      # Generate 500 matches  statscli seed          # Generate 100 matchesExamples:  status          Show database status  clear           Clear all test data from databases  seed [count]    Generate test matches (default: 100)Commands:  statscli <command> [options]Usage:MOHAA Stats CLI - Test Data Generator	fmt.Println(`func printUsage() {// ============================================================================// Main CLI// ============================================================================}	return nil	fmt.Println("    redis-cli FLUSHALL")	fmt.Println("  Note: Redis flush requires redis-cli. Run manually if needed:")	// Use redis-cli to flushfunc clearRedis() error {}	return nil		}		fmt.Printf("  âœ“ Cleared %s\n", table)		}			continue			fmt.Printf("  Warning: Could not truncate %s: %v\n", table, err)		if err != nil {		_, err := db.Exec(fmt.Sprintf("TRUNCATE TABLE %s CASCADE", table))	for _, table := range tables {		}		"player_identities",		"matches",		"match_participants",		"player_achievements",	tables := []string{		defer db.Close()	}		return fmt.Errorf("failed to connect to postgres: %v", err)	if err != nil {	db, err := sql.Open("postgres", PostgresURL)func clearPostgres() error {}	return nil		}		}			fmt.Printf("  âœ“ Cleared %s\n", table)		if resp.StatusCode == http.StatusOK {				resp.Body.Close()		}			continue			fmt.Printf("  Warning: Could not truncate %s: %v\n", table, err)		if err != nil {		resp, err := client.Do(req)				}			return fmt.Errorf("failed to create request for %s: %v", table, err)		if err != nil {		req, err := http.NewRequest("POST", ClickHouseURL, bytes.NewBufferString(query))		query := fmt.Sprintf("TRUNCATE TABLE IF EXISTS %s", table)	for _, table := range tables {		client := &http.Client{Timeout: 10 * time.Second}		}		"leaderboard_map",		"leaderboard_weapon",		"leaderboard_weekly",		"leaderboard_global",		"server_activity_mv",		"match_summary_mv",		"death_heatmap_mv",		"kill_heatmap_mv",		"map_stats_mv",		"weapon_stats_mv",		"player_stats_daily_mv",		"player_kills_hourly_mv",		"raw_events",	tables := []string{func clearClickHouse() error {// ============================================================================// Clear Functions// ============================================================================}	m.stats.AddEvents(1)		}		return		m.stats.AddError()	if resp.StatusCode != http.StatusAccepted && resp.StatusCode != http.StatusOK {		defer resp.Body.Close()	}		return		m.stats.AddError()	if err != nil {	resp, err := m.client.Do(req)		req.Header.Set("Authorization", "Bearer "+ServerToken)	req.Header.Set("Content-Type", "application/json")		}		return		m.stats.AddError()	if err != nil {	req, err := http.NewRequest("POST", APIURL, bytes.NewBuffer(jsonData))	jsonData, _ := json.Marshal(data)		data["server_id"] = m.server.ID	data["map_name"] = m.mapNamefunc (m *MatchSimulator) sendEvent(data map[string]interface{}) {}	})		"message":     messages[rand.Intn(len(messages))],		"player_team": player.Team,		"player_guid": player.GUID,		"player_name": player.Name,		"timestamp":   m.baseTS,		"match_id":    m.matchID,		"type":        "chat",	m.sendEvent(map[string]interface{}{		}		"wp", "go go go", "fall back", "ez", "rekt",		"cover me", "need backup", "grenade!", "sniper!", "nice",		"gg", "nice shot", "lol", "noob", "haha", "rush B",	messages := []string{func (m *MatchSimulator) simulateChat(player Player) {}	}		m.sendEvent(data)		data["timestamp"] = m.baseTS		data["type"] = "grenade_explode"		m.baseTS += float64(rand.Intn(3) + 1)	} else if event == "grenade_throw" {		m.sendEvent(data)		data["timestamp"] = m.baseTS		data["type"] = "ladder_dismount"		m.baseTS += float64(rand.Intn(5) + 1)	if event == "ladder_mount" {	// Follow-up events		m.sendEvent(data)		}		}			data["projectile"] = "Stielhandgranate"		} else {			data["projectile"] = "Grenade"		if rand.Float32() > 0.5 {	case "grenade_throw":		data["ammo_remaining"] = rand.Intn(30)		data["weapon"] = selectWeapon(player)	case "reload":		data["new_weapon"] = weapons[rand.Intn(len(weapons))]		data["old_weapon"] = weapons[rand.Intn(len(weapons))]	case "weapon_change":		data["count"] = 1 + rand.Intn(3)		data["item"] = items[rand.Intn(len(items))]	case "item_pickup":	switch event {		}		"pos_z":       z,		"pos_y":       y,		"pos_x":       x,		"player_team": player.Team,		"player_guid": player.GUID,		"player_name": player.Name,		"timestamp":   m.baseTS,		"match_id":    m.matchID,		"type":        event,	data := map[string]interface{}{		event := events[rand.Intn(len(events))]	events := []string{"item_pickup", "use", "ladder_mount", "weapon_change", "reload", "grenade_throw"}		x, y, z := generatePosition(m.mapName)func (m *MatchSimulator) simulateInteraction(player Player) {}	m.sendEvent(data)		}		data["swam"] = rand.Float32() * 20		data["sprinted"] = rand.Float32() * 200		data["walked"] = rand.Float32() * 100	} else if event == "distance" {		data["fall_height"] = rand.Float32() * 5		data["timestamp"] = m.baseTS		data["type"] = "land"		m.baseTS += 0.5 + rand.Float64()		m.sendEvent(data)		// Land event after jump	if event == "jump" {		}		"pos_z":       z,		"pos_y":       y,		"pos_x":       x,		"player_team": player.Team,		"player_guid": player.GUID,		"player_name": player.Name,		"timestamp":   m.baseTS,		"match_id":    m.matchID,		"type":        event,	data := map[string]interface{}{		event := events[rand.Intn(len(events))]	events := []string{"jump", "crouch", "prone", "distance"}		x, y, z := generatePosition(m.mapName)func (m *MatchSimulator) simulateMovement(player Player) {}	}		}			})				"pos_z":       newZ,				"pos_y":       newY,				"pos_x":       newX,				"player_team": victim.Team,				"player_guid": victim.GUID,				"player_name": victim.Name,				"timestamp":   m.baseTS,				"match_id":    m.matchID,				"type":        "spawn",			m.sendEvent(map[string]interface{}{			newX, newY, newZ := generatePosition(m.mapName)			m.baseTS += float64(rand.Intn(3) + 2)			// Respawn victim						}				})					"distance":      distance,					"weapon":        weapon,					"victim_guid":   victim.GUID,					"victim_name":   victim.Name,					"attacker_guid": attacker.GUID,					"attacker_name": attacker.Name,					"timestamp":     m.baseTS + 0.15,					"match_id":      m.matchID,					"type":          "headshot",				m.sendEvent(map[string]interface{}{			if hitloc == "head" {			// Headshot event						})				"inflictor":   attacker.Name,				"pos_z":       vZ,				"pos_y":       vY,				"pos_x":       vX,				"player_team": victim.Team,				"player_guid": victim.GUID,				"player_name": victim.Name,				"timestamp":   m.baseTS + 0.15,				"match_id":    m.matchID,				"type":        "death",			m.sendEvent(map[string]interface{}{			// Death event						})				"hitloc":        hitloc,				"damage":        100,				"weapon":        weapon,				"victim_team":   victim.Team,				"victim_guid":   victim.GUID,				"victim_name":   victim.Name,				"attacker_yaw":  aYaw,				"attacker_pitch": aPitch,				"attacker_z":    aZ,				"attacker_y":    aY,				"attacker_x":    aX,				"attacker_team": attacker.Team,				"attacker_guid": attacker.GUID,				"attacker_name": attacker.Name,				"timestamp":     m.baseTS + 0.15,				"match_id":      m.matchID,				"type":          "kill",			m.sendEvent(map[string]interface{}{		if rand.Float32() < float32(damage)/150.0 {		// 4. Kill (chance based on damage)				})			"hitloc":        hitloc,			"damage":        damage,			"weapon":        weapon,			"victim_team":   victim.Team,			"victim_guid":   victim.GUID,			"victim_name":   victim.Name,			"attacker_z":    aZ,			"attacker_y":    aY,			"attacker_x":    aX,			"attacker_team": attacker.Team,			"attacker_guid": attacker.GUID,			"attacker_name": attacker.Name,			"timestamp":     m.baseTS + 0.1,			"match_id":      m.matchID,			"type":          "damage",		m.sendEvent(map[string]interface{}{				}			damage = 80 + rand.Intn(40)		if hitloc == "head" {		damage := 15 + rand.Intn(40)		// 3. Damage				})			"pos_z":         aZ,			"pos_y":         aY,			"pos_x":         aX,			"hitloc":        hitloc,			"weapon":        weapon,			"target_guid":   victim.GUID,			"target_name":   victim.Name,			"player_team":   attacker.Team,			"player_guid":   attacker.GUID,			"player_name":   attacker.Name,			"timestamp":     m.baseTS + 0.05,			"match_id":      m.matchID,			"type":          "weapon_hit",		m.sendEvent(map[string]interface{}{	if rand.Float32() < attacker.Skill*0.7 {	// 2. Hit (based on skill)		})		"ammo_remaining": rand.Intn(30) + 1,		"aim_yaw":       aYaw,		"aim_pitch":     aPitch,		"pos_z":         aZ,		"pos_y":         aY,		"pos_x":         aX,		"weapon":        weapon,		"player_team":   attacker.Team,		"player_guid":   attacker.GUID,		"player_name":   attacker.Name,		"timestamp":     m.baseTS,		"match_id":      m.matchID,		"type":          "weapon_fire",	m.sendEvent(map[string]interface{}{	// 1. Weapon Fire		distance := calculateDistance(aX, aY, aZ, vX, vY, vZ)	vX, vY, vZ := generatePosition(m.mapName)	// Victim position		aPitch, aYaw := generateAimAngles()	aX, aY, aZ := generatePosition(m.mapName)	// Attacker position/aim		hitloc := selectHitloc(attacker.Skill)	weapon := selectWeapon(attacker)		}		}			break		if victim.GUID != attacker.GUID {		victim = m.players[rand.Intn(len(m.players))]	for {	var victim Player	// Select victim (different team preferred)func (m *MatchSimulator) simulateCombat(attacker Player) {}	return "chat"	}		return "interaction"	} else if r < 0.95 {		return "movement"	} else if r < 0.85 {		return "combat"	if r < 0.65 {	r := rand.Float32()func (m *MatchSimulator) selectEventType() string {}	})		"winning_team": []string{"allies", "axis"}[rand.Intn(2)],		"round_number": roundNum,		"timestamp":    m.baseTS,		"match_id":     m.matchID,		"type":         "round_end",	m.sendEvent(map[string]interface{}{	m.baseTS += float64(rand.Intn(3) + 1)	// Round End		}		}			m.simulateChat(actor)		case "chat":			m.simulateInteraction(actor)		case "interaction":			m.simulateMovement(actor)		case "movement":			m.simulateCombat(actor)		case "combat":		switch eventType {				eventType := m.selectEventType()		actor := m.players[rand.Intn(len(m.players))]				m.baseTS += float64(rand.Intn(3)) + rand.Float64()	for i := 0; i < numEvents; i++ {		numEvents := 50 + rand.Intn(150)	// Simulate 50-200 combat events per round		})		"total_rounds": totalRounds,		"round_number": roundNum,		"timestamp":    m.baseTS,		"match_id":     m.matchID,		"type":         "round_start",	m.sendEvent(map[string]interface{}{	// Round Start		m.baseTS += float64(rand.Intn(5) + 1)func (m *MatchSimulator) simulateRound(roundNum, totalRounds int) {}	m.stats.AddMatch()		})		"duration":     m.baseTS - float64(time.Now().Add(-time.Duration(rand.Intn(720))*time.Hour).Unix()),		"winning_team": winningTeam,		"axis_score":   axisScore,		"allies_score": alliesScore,		"timestamp":    m.baseTS,		"server_token": ServerToken,		"server_id":    m.server.ID,		"match_id":     m.matchID,		"type":         "match_end",	m.sendEvent(map[string]interface{}{		}		winningTeam = "axis"	} else if axisScore > alliesScore {		winningTeam = "allies"	if alliesScore > axisScore {	winningTeam := "draw"	axisScore := rand.Intn(50)	alliesScore := rand.Intn(50)	// 5. Match End		}		})			"player_guid": p.GUID,			"player_name": p.Name,			"timestamp":   m.baseTS,			"match_id":    m.matchID,			"type":        "disconnect",		m.sendEvent(map[string]interface{}{		m.baseTS += float64(rand.Intn(5))	for _, p := range m.players {	// 4. Disconnect players		}		m.simulateRound(round, numRounds)	for round := 1; round <= numRounds; round++ {	numRounds := 1 + rand.Intn(5)	// 3. Simulate gameplay (rounds)		}		})			"pos_z":       z,			"pos_y":       y,			"pos_x":       x,			"player_team": p.Team,			"player_guid": p.GUID,			"player_name": p.Name,			"timestamp":   m.baseTS + 0.5,			"match_id":    m.matchID,			"type":        "spawn",		m.sendEvent(map[string]interface{}{		x, y, z := generatePosition(m.mapName)		// Spawn				})			"client_num":  rand.Intn(20),			"player_team": p.Team,			"player_guid": p.GUID,			"player_name": p.Name,			"timestamp":   m.baseTS,			"match_id":    m.matchID,			"type":        "connect",		m.sendEvent(map[string]interface{}{		m.baseTS += float64(rand.Intn(3) + 1)	for _, p := range m.players {	// 2. Connect all players		})		"timelimit":    fmt.Sprintf("%d", 15+rand.Intn(15)),		"maxclients":   fmt.Sprintf("%d", 20+rand.Intn(12)),		"timestamp":    m.baseTS,		"gametype":     gametypes[rand.Intn(len(gametypes))],		"map_name":     m.mapName,		"server_token": ServerToken,		"server_id":    m.server.ID,		"match_id":     m.matchID,		"type":         "match_start",	m.sendEvent(map[string]interface{}{	// 1. Match Startfunc (m *MatchSimulator) Run() {}	}		baseTS:  float64(time.Now().Add(-time.Duration(rand.Intn(720))*time.Hour).Unix()),		players: matchPlayers,		mapName: mapName,		server:  struct{ ID, Name string }{server.ID, server.Name},		matchID: uuid.New().String(),		stats:   stats,		client:  client,	return &MatchSimulator{		}		}			matchPlayers[i].Team = "axis"		} else {			matchPlayers[i].Team = "allies"		if i%2 == 0 {	for i := range matchPlayers {	// Balance teams		matchPlayers := shuffled[:numPlayers]	rand.Shuffle(len(shuffled), func(i, j int) { shuffled[i], shuffled[j] = shuffled[j], shuffled[i] })	copy(shuffled, players)	shuffled := make([]Player, len(players))	numPlayers := 8 + rand.Intn(9)	// Select 8-16 random players for this match		mapName := maps[rand.Intn(len(maps))]	server := servers[rand.Intn(len(servers))]func NewMatchSimulator(client *http.Client, stats *Stats) *MatchSimulator {}	baseTS  float64	players []Player	mapName string	server  struct{ ID, Name string }	matchID string	stats   *Stats	client  *http.Clienttype MatchSimulator struct {// ============================================================================// Match Simulator// ============================================================================}	return hitlocs[rand.Intn(len(hitlocs))]	}		return "torso_upper"	if rand.Float32() < 0.5 {	}		return "head"	if rand.Float32() < skill*0.3 {	// Higher skill = more headshotsfunc selectHitloc(skill float32) string {}	return weapons[rand.Intn(len(weapons))]	}		return player.Favorite	if rand.Float32() < 0.6 {	// 60% chance to use favorite weaponfunc selectWeapon(player Player) string {}	return float32(math.Sqrt(float64(dx*dx + dy*dy + dz*dz)))	dz := z2 - z1	dy := y2 - y1	dx := x2 - x1func calculateDistance(x1, y1, z1, x2, y2, z2 float32) float32 {}	return	yaw = rand.Float32() * 360     // 0 to 360 degrees	pitch = rand.Float32()*60 - 30 // -30 to 30 degreesfunc generateAimAngles() (pitch, yaw float32) {}	return baseX, baseY, baseZ	baseZ := rand.Float32()*200 + 10	baseY := rand.Float32()*4000 - 2000	baseX := rand.Float32()*4000 - 2000	// Generate semi-realistic positions based on mapfunc generatePosition(mapName string) (x, y, z float32) {// ============================================================================// Event Generators// ============================================================================}	fmt.Printf("Rate:         %.0f events/sec\n", float64(events)/elapsed)	fmt.Printf("Duration:     %.2fs\n", elapsed)	fmt.Printf("Errors:       %d\n", errors)	fmt.Printf("Events sent:  %d\n", events)	fmt.Printf("Matches:      %d\n", matches)	fmt.Printf("\n=== Seeding Complete ===\n")		matches := atomic.LoadInt64(&s.matchesRun)	errors := atomic.LoadInt64(&s.eventsErrors)	events := atomic.LoadInt64(&s.eventsSent)	elapsed := time.Since(s.startTime).Seconds()func (s *Stats) Print() {}	atomic.AddInt64(&s.matchesRun, 1)func (s *Stats) AddMatch() {}	atomic.AddInt64(&s.eventsErrors, 1)func (s *Stats) AddError() {}	atomic.AddInt64(&s.eventsSent, int64(n))func (s *Stats) AddEvents(n int) {}	startTime    time.Time	matchesRun   int64	eventsErrors int64	eventsSent   int64type Stats struct {// ============================================================================// Statistics tracking// ============================================================================}	{"srv-asia-1", "Asia Pacific #1"},	{"srv-eu-west-1", "EU West #1"},	{"srv-eu-central-1", "EU Central #1"},	{"srv-us-west-1", "US West #1"},	{"srv-us-east-1", "US East #1"},}{	Name string	ID   stringvar servers = []struct {var items = []string{"health_large", "health_small", "ammo_thompson", "ammo_mp40", "ammo_rifle", "armor"}var gametypes = []string{"dm", "tdm", "obj", "lib", "ctf"}}	"tdm/v2rocket", "tdm/destroyed_village", "tdm/bridge",	"lib/stalingrad", "lib/hunt", "lib/flughafen",	"obj/obj_team1", "obj/obj_team2", "obj/obj_team3", "obj/obj_team4",	"dm/mohdm1", "dm/mohdm2", "dm/mohdm3", "dm/mohdm4", "dm/mohdm5", "dm/mohdm6", "dm/mohdm7",var maps = []string{}	"left_leg_upper", "left_leg_lower", "right_leg_upper", "right_leg_lower",	"left_arm_upper", "left_arm_lower", "right_arm_upper", "right_arm_lower",	"head", "neck", "torso_upper", "torso_lower",var hitlocs = []string{}	"Shotgun", "Fists",	"Colt .45", "Walther P38", "Grenade", "Stielhandgranate",	"Springfield", "Kar98k Sniper", "Bazooka", "Panzerschreck",	"Thompson", "MP40", "M1 Garand", "Kar98k", "BAR", "STG44",var weapons = []string{}	{"VeteranVic", "GUID_025", "allies", 0.86, "defensive", "M1 Garand"},	{"Casual.Gamer", "GUID_024", "axis", 0.40, "defensive", "Kar98k"},	{"TryHard", "GUID_023", "allies", 0.84, "aggressive", "BAR"},	{"Noob123", "GUID_022", "axis", 0.25, "rusher", "MP40"},	{"ProPlayer", "GUID_021", "allies", 0.97, "aggressive", "Thompson"},	{"DayWalker", "GUID_020", "axis", 0.68, "aggressive", "STG44"},	{"NightOwl", "GUID_019", "allies", 0.73, "sniper", "Springfield"},	{"CaptainFlank", "GUID_018", "axis", 0.79, "rusher", "MP40"},	{"MedicMike", "GUID_017", "allies", 0.62, "defensive", "Thompson"},	{"GrenadeKing", "GUID_016", "axis", 0.58, "rusher", "Grenade"},	{"TankBuster", "GUID_015", "allies", 0.65, "aggressive", "Bazooka"},	{"QuickScope", "GUID_014", "axis", 0.92, "sniper", "Kar98k"},	{"IronSights", "GUID_013", "allies", 0.77, "defensive", "M1 Garand"},	{"ShadowKill", "GUID_012", "axis", 0.82, "sniper", "Kar98k"},	{"FragMaster", "GUID_011", "allies", 0.88, "aggressive", "Thompson"},	{"Bot.Alice", "GUID_010", "axis", 0.50, "defensive", "Kar98k"},	{"Noob.Slayer", "GUID_009", "allies", 0.90, "aggressive", "Thompson"},	{"Rusher.B", "GUID_008", "axis", 0.75, "aggressive", "MP40"},	{"Camper.Joe", "GUID_007", "allies", 0.55, "defensive", "BAR"},	{"Running.Man", "GUID_006", "axis", 0.60, "rusher", "STG44"},	{"Sniper.Wolf", "GUID_005", "allies", 0.95, "sniper", "Springfield"},	{"Major.Lag", "GUID_004", "axis", 0.70, "sniper", "Kar98k"},	{"Pvt.Panic", "GUID_003", "allies", 0.45, "rusher", "M1 Garand"},	{"Cpt.Logic", "GUID_002", "axis", 0.80, "defensive", "MP40"},	{"Sgt.Physics", "GUID_001", "allies", 0.85, "aggressive", "Thompson"},var players = []Player{}	Favorite string  // Favorite weapon	Style    string  // "aggressive", "defensive", "sniper", "rusher"	Skill    float32 // 0.0-1.0 affects accuracy, reaction time	Team     string	GUID     string	Name     stringtype Player struct {// ============================================================================// Player Pool - Diverse set of players for realistic data// ============================================================================const ClickHouseURL = "http://localhost:8123"// ClickHouse connectionconst PostgresURL = "postgres://mohaa:admin123@localhost:5432/mohaa_stats?sslmode=disable"// PostgreSQL connection (for clearing))	Concurrency = 10	ServerToken = "test-token"	APIURL      = "http://localhost:8080/api/v1/ingest/events"const (// ============================================================================// Configuration// ============================================================================)	_ "github.com/lib/pq"	"github.com/google/uuid"	"time"	"sync/atomic"	"sync"	"os"	"net/http"	"math/rand"	"math"	"fmt"	"encoding/json"	"database/sql"	"bytes"import (package main