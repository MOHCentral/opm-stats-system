// ============================================================================
// OpenMOHAA Telemetry Tracker v2.0
// High-Throughput Event Collection for Mass Stats System
// ============================================================================
//
// This tracker sends atomic events directly to the API.
// The API handles batching, worker pools, and database writes.
//
// Architecture:
// - Events fire immediately via curl_post (no client-side batching)
// - URL-encoded payloads with rich metadata (positions, angles, timestamps)
// - Server session/match context included in each event
// - API returns 202 Accepted immediately (async processing)
//
// ============================================================================
// CONFIGURATION
// ============================================================================

level.api_base_url = "http://localhost:8080"
    level.api_events_endpoint = "/api/v1/ingest/events"
    level.server_token = "dev-server-token-replace-in-production"
    level.server_id = "dev-server-01"

    // Session tracking
    level.session_id = ""
    level.match_id = ""
    level.match_start_time = 0
    level.round_number = 0
    level.map_name = ""

    // Team scores (for heartbeat)
    level.allies_score = 0
    level.axis_score = 0

    // Debug
    level.tracker_debug = 1

    // ============================================================================
    // MAIN INITIALIZATION
    // ============================================================================

main:
        println "=============================================="
        println "OpenMOHAA Telemetry Tracker v2.0 Initializing"
        println "=============================================="
    
        // Generate session ID
        level.session_id = "sess_" + level.time
        level.match_start_time = level.time
        level.map_name = getcvar "mapname"
    
        println ("Session ID: " + level.session_id)
        println ("Map: " + level.map_name)
        println ("API Endpoint: " + level.api_base_url + level.api_events_endpoint)
    
        // Register console commands
        registercmd "login" "cmd_login"
        registercmd "logout" "cmd_logout"
        registercmd "claim" "cmd_claim"
        registercmd "stats" "cmd_stats"
        registercmd "whoami" "cmd_whoami"
    
        // ========================================================================
        // EVENT SUBSCRIPTIONS
        // ========================================================================
        // Initialization logic is split into separate scripts for organization.
        
        thread global/tracker_init_player.scr::init
        thread global/tracker_init_server.scr::init

    
        println "Subscribed to all 30 player events."
    
        // Send match_start event
        thread send_match_start
    
        // Start heartbeat loop (every 30 seconds)
        thread heartbeat_loop
        
        // Start API flush loop (every 2 seconds)
        thread global/tracker_common.scr::flush_loop
    
        // TODO: Implement per-player HUD notifications using hud_draw
        // hud_draw allows rendering text/elements on individual player screens
        // For now we use global iprintln. Replace with hud_draw when example available.
        thread player_hud_manager
    
        println "Tracker initialization complete."
        println "=============================================="
    end

    // ============================================================================
    // PLAYER HUD MANAGER (Placeholder for per-player notifications)
    // ============================================================================
    // TODO: Implement using hud_draw for per-player messages
    // Example usage we need to figure out:
    //   hud_draw local.player "stats" 10 10 "Kills: 5"
    //   hud_draw local.player "notification" 320 240 "Achievement Unlocked!"
    //
    // For now, this thread is empty. When we have hud_draw examples:
    // - Create HUD elements per player on spawn
    // - Update stats display periodically
    // - Show notifications for achievements/kills
    // ============================================================================

player_hud_manager:
    // Empty placeholder - waiting for hud_draw documentation/examples
    // When implemented, this will:
    // 1. Track active players and their HUD elements
    // 2. Update kill/death counters on HUD
    // 3. Show achievement notifications
    // 4. Display session stats
    end

    // ============================================================================
    // HUD NOTIFICATION SYSTEM
    // ============================================================================

show_hud_notification local.player local.message local.r local.g local.b:
        if (!local.player) end
        
            // MoHAA hudprint sends message to the specific player's chat area
        local.player hudprint (">>> " + local.message + "\n")
    end

    // ============================================================================
    // CONSOLE COMMANDS
    // ============================================================================
    // These commands integrate with the SMF forum login token system.
    // Players generate tokens at the forum and use them in-game to link identities.
    // Once authenticated, the SMF member_id is used for all stat tracking.
    // ============================================================================

cmd_login local.player local.args:
        if (local.args.size < 1) {
            iprintln "Usage: login <token>"
            iprintln "Get your token from the forum: /action=mohaatoken"
            end
        }
    
        local.token = local.args[0]
    
        // Store pending auth info on player
        local.player.pending_auth_token = local.token
        local.player.is_authenticated = 0
        local.player.smf_member_id = 0
    
        iprintln "Verifying login token..."
        println ("Player " + local.player.netname + " attempting auth with SMF token")
    
        // HUD Notification: Verifying
        thread show_hud_notification local.player "Verifying Token..." 1.0 1.0 0.0 // Yellow
    
        // Call SMF auth API endpoint
        // This verifies the token and returns the SMF member_id
        local.url = level.api_base_url + "/api/v1/auth/smf-verify"
        local.data = "token=" + local.token
        local.data = local.data + "&guid=" + (getclientnum local.player)
        local.data = local.data + "&player_name=" + local.player.netname
        local.data = local.data + "&server_ip=" + (getcvar "net_ip")
        local.data = local.data + "&server_port=" + (getcvar "net_port")
        local.data = local.data + "&server_id=" + level.server_id
    
        // Store player reference for callback
        level.pending_auth_player = local.player
    
        curl_post local.url local.data "global/tracker.scr::on_smf_auth_verify"
    end

cmd_logout local.player local.args:
        if (!local.player.is_authenticated) {
            iprintln "You are not logged in."
            end
        }
    
        // Send logout notification to SMF
        local.url = level.api_base_url + "/api/v1/auth/smf-logout"
        local.data = "member_id=" + local.player.smf_member_id
        local.data = local.data + "&guid=" + (getclientnum local.player)
        curl_post local.url local.data "global/tracker_common.scr::on_http_callback"
    
        // Clear auth state
        local.player.is_authenticated = 0
        local.player.smf_member_id = 0
        local.player.smf_member_name = ""
        local.player.auth_token = ""
    
        iprintln "You have been logged out."
        println ("Player " + local.player.netname + " logged out")
    
        // HUD Notification: Logged Out
        thread show_hud_notification local.player "Logged Out" 0.7 0.7 0.7 // Grey
    end

cmd_claim local.player local.args:
    // This is now handled through the SMF login system
    // Players link their identity by logging in with their forum token
        iprintln "Identity linking is now done through forum login."
        iprintln "Visit the forum and generate a login token, then use /login <token>"
    end

cmd_stats local.player local.args:
        iprintln "Fetching your stats..."
    
        // Use SMF member_id if authenticated, otherwise use GUID
        if (local.player.is_authenticated && local.player.smf_member_id > 0) {
            local.url = level.api_base_url + "/api/v1/stats/member/" + local.player.smf_member_id
        } else {
            local.url = level.api_base_url + "/api/v1/stats/player/" + (getclientnum local.player)
        }
    
        curl_get local.url "global/tracker.scr::on_stats_response"
    end

cmd_whoami local.player local.args:
        if (local.player.is_authenticated) {
            iprintln ("Logged in as: " + local.player.smf_member_name + " (ID: " + local.player.smf_member_id + ")")
        } else {
            iprintln "Not logged in. Use /login <token> to authenticate."
        }
    end

    // ============================================================================
    // MATCH LIFECYCLE EVENTS
    // ============================================================================

send_match_start:
        level.match_id = "match_" + level.session_id + "_" + level.time
        level.round_number = 1
    
        local.payload = global/tracker_common.scr::build_base_payload "match_start"
        local.payload = local.payload + "&server_id=" + level.server_id
        local.payload = local.payload + "&map_name=" + level.map_name
        local.payload = local.payload + "&gametype=" + (getcvar "g_gametype")
        local.payload = local.payload + "&timelimit=" + (getcvar "timelimit")
        local.payload = local.payload + "&fraglimit=" + (getcvar "fraglimit")
        local.payload = local.payload + "&maxclients=" + (getcvar "sv_maxclients")
    
        thread global/tracker_common.scr::queue_event local.payload
        println ("MATCH START: " + level.match_id)
    end

send_match_end local.winning_team local.allies_score local.axis_score:
        local.payload = global/tracker_common.scr::build_base_payload "match_end"
        local.payload = local.payload + "&server_id=" + level.server_id
        local.payload = local.payload + "&map_name=" + level.map_name
        local.payload = local.payload + "&duration=" + (level.time - level.match_start_time)
        local.payload = local.payload + "&winning_team=" + local.winning_team
        local.payload = local.payload + "&allies_score=" + local.allies_score
        local.payload = local.payload + "&axis_score=" + local.axis_score
        local.payload = local.payload + "&total_rounds=" + level.round_number
    
        thread global/tracker_common.scr::queue_event local.payload
        println ("MATCH END: " + level.match_id + " Winner: " + local.winning_team)
    end

send_round_start:
        level.round_number = (level.round_number + 1)
        if (level.round_number == NIL) level.round_number = 1

            local.payload = global/tracker_common.scr::build_base_payload "round_start"
        local.payload = local.payload + "&round_number=" + level.round_number

        thread global/tracker_common.scr::queue_event local.payload
    end

send_round_end local.winning_team:
        local.payload = global/tracker_common.scr::build_base_payload "round_end"
        local.payload = local.payload + "&round_number=" + level.round_number
        local.payload = local.payload + "&winning_team=" + local.winning_team

        thread global/tracker_common.scr::queue_event local.payload
    end

heartbeat_loop:
        wait 30

        local.payload = global/tracker_common.scr::build_base_payload "heartbeat"
        local.payload = local.payload + "&round_number=" + level.round_number
        local.payload = local.payload + "&allies_score=" + level.allies_score
        local.payload = local.payload + "&axis_score=" + level.axis_score
        local.payload = local.payload + "&player_count=" + level.playercount

        thread global/tracker_common.scr::queue_event local.payload
        thread heartbeat_loop
    end

    // ============================================================================
    // COMBAT EVENT HANDLERS
    // ============================================================================
    // All combat events include SMF member_id when player is authenticated.
    // The API uses member_id as the primary identifier for stats aggregation.
    // ============================================================================

    // Helper: Build player payload with optional SMF member_id
    // Local build_player_payload removed - using global/tracker_common.scr version

on_player_kill local.attacker local.victim local.inflictor local.hitloc local.mod:
        if (local.attacker) {
            if (local.attacker.shots_hit == NIL) local.attacker.shots_hit = 0
                local.attacker.shots_hit++
        }

        local.payload = global/tracker_common.scr::build_base_payload "player_kill"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.attacker "attacker"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.victim "victim"
        local.payload = local.payload + "&inflictor=" + local.inflictor
        local.payload = local.payload + "&hitlocation=" + local.hitloc
        local.payload = local.payload + "&mod=" + local.mod

        thread global/tracker_common.scr::queue_event local.payload
    end

on_player_death local.inflictor:
        local.payload = global/tracker_common.scr::build_base_payload "death"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&inflictor=" + local.inflictor

        thread global/tracker_common.scr::queue_event local.payload
    end

on_player_damage local.attacker local.amount local.mod:
        local.payload = global/tracker_common.scr::build_base_payload "damage"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "victim"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.attacker "attacker"
        local.payload = local.payload + "&damage=" + local.amount
        local.payload = local.payload + "&weapon=" + local.mod

        thread global/tracker_common.scr::queue_event local.payload
    end

on_player_pain local.player local.attacker local.damage local.mod local.location:
        local.payload = global/tracker_common.scr::build_base_payload "player_pain"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.player "victim"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.attacker "attacker"
        local.payload = local.payload + "&damage=" + local.damage
        local.payload = local.payload + "&weapon=" + local.mod
        local.payload = local.payload + "&hitloc=" + local.location
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_weapon_fire local.player local.weapon_name local.ammo_left:
    // Track localized accuracy
        if (local.player.shots_fired == NIL) local.player.shots_fired = 0
            local.player.shots_fired++

        local.payload = global/tracker_common.scr::build_base_payload "weapon_fire"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.player "player"
        local.payload = local.payload + "&weapon=" + local.weapon_name
        local.payload = local.payload + "&ammo_remaining=" + local.ammo_left
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_weapon_hit local.player local.target local.location:
        if (local.player.shots_hit == NIL) local.player.shots_hit = 0
            local.player.shots_hit++

        local.payload = global/tracker_common.scr::build_base_payload "weapon_hit"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.player "player"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.target "target"
        local.payload = local.payload + "&hitloc=" + local.location
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_player_headshot local.target local.weapon:
        local.payload = global/tracker_common.scr::build_base_payload "headshot"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "attacker"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.target "victim"
        local.payload = local.payload + "&weapon=" + local.weapon

        thread global/tracker_common.scr::queue_event local.payload
    end

on_weapon_reload local.weapon:
        local.payload = global/tracker_common.scr::build_base_payload "reload"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&weapon=" + local.weapon
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_weapon_change local.old local.new:
        local.payload = global/tracker_common.scr::build_base_payload "weapon_change"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&old_weapon=" + local.old
        local.payload = local.payload + "&new_weapon=" + local.new
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_grenade_throw local.proj:
        local.payload = global/tracker_common.scr::build_base_payload "grenade_throw"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&projectile=" + local.proj
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_grenade_explode local.proj:
        local.payload = global/tracker_common.scr::build_base_payload "grenade_explode"
        local.payload = local.payload + "&projectile=" + local.proj
    
        thread global/tracker_common.scr::queue_event local.payload
    end

    // ============================================================================
    // MOVEMENT EVENT HANDLERS
    // ============================================================================

on_player_jump local.dummy:
        local.payload = global/tracker_common.scr::build_base_payload "jump"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_player_land local.height:
        local.payload = global/tracker_common.scr::build_base_payload "land"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&fall_height=" + local.height
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_player_crouch local.dummy:
        local.payload = global/tracker_common.scr::build_base_payload "crouch"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_player_prone local.dummy:
        local.payload = global/tracker_common.scr::build_base_payload "prone"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_player_distance local.walked local.sprinted local.swam local.driven:
        local.payload = global/tracker_common.scr::build_base_payload "distance"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&walked=" + local.walked
        local.payload = local.payload + "&sprinted=" + local.sprinted
        local.payload = local.payload + "&swam=" + local.swam
        local.payload = local.payload + "&driven=" + local.driven
    
        thread global/tracker_common.scr::queue_event local.payload
    end

    // ============================================================================
    // INTERACTION EVENT HANDLERS
    // ============================================================================

on_ladder_mount local.ladder:
        local.payload = global/tracker_common.scr::build_base_payload "ladder_mount"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_ladder_dismount local.ladder:
        local.payload = global/tracker_common.scr::build_base_payload "ladder_dismount"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_item_pickup local.item local.count:
        local.payload = global/tracker_common.scr::build_base_payload "item_pickup"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&item=" + local.item
        local.payload = local.payload + "&count=" + local.count
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_item_drop local.item:
        local.payload = global/tracker_common.scr::build_base_payload "item_drop"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&item=" + local.item
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_player_use local.entity:
        local.payload = global/tracker_common.scr::build_base_payload "use"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&entity=" + local.entity
    
        thread global/tracker_common.scr::queue_event local.payload
    end

    // ============================================================================
    // SESSION EVENT HANDLERS
    // ============================================================================

on_client_connect local.clientnum:
        local.payload = global/tracker_common.scr::build_base_payload "connect"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&client_num=" + local.clientnum
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_client_disconnect local.dummy:
        local.payload = global/tracker_common.scr::build_base_payload "disconnect"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
    
        thread global/tracker_common.scr::queue_event local.payload
    end

on_client_begin local.player:
    // Initialize session-based counters
        local.player.shots_fired = 0
        local.player.shots_hit = 0

        local.payload = global/tracker_common.scr::build_base_payload "client_begin"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.player "player"

        thread global/tracker_common.scr::queue_event local.payload
    
        // Start per-player accuracy summary thread
        thread player_accuracy_loop local.player
    end

player_accuracy_loop local.player:
        while (local.player) {
            wait 10 // Every 10 seconds send summary
        
            if (!local.player) end

                if (local.player.shots_fired > 0) {
                local.payload = global/tracker_common.scr::build_base_payload "accuracy_summary"
                local.payload = local.payload + global/tracker_common.scr::build_player_payload_compact local.player "player"
                local.payload = local.payload + "&fired=" + local.player.shots_fired
                local.payload = local.payload + "&hits=" + local.player.shots_hit
            
                thread global/tracker_common.scr::queue_event local.payload
            }
        }
    end

on_team_join local.old_team local.new_team:
        if (level.tracker_debug) { println "EVENT: on_team_join local.old_team local.new_team:" }
            local.payload = global/tracker_common.scr::build_base_payload "team_join"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload self "player"
        local.payload = local.payload + "&old_team=" + local.old_team
        local.payload = local.payload + "&new_team=" + local.new_team

        thread global/tracker_common.scr::queue_event local.payload
    end

    // on_player_say is handled in tracker_interaction_ext.scr

    // ============================================================================
    // HTTP TRANSPORT LAYER
    // ============================================================================


on_http_callback local.success local.response local.http_code:
        if (level.tracker_debug) {
            if (local.success) {
                println ("HTTP OK [" + local.http_code + "]")
            } else {
                println ("HTTP FAIL [" + local.http_code + "]: " + local.response)
            }
        }
    end

    // ============================================================================
    // SMF AUTHENTICATION CALLBACKS
    // ============================================================================
    // These handle responses from the SMF login token verification system.
    // On success, we store the SMF member_id on the player for use in all events.
    // ============================================================================

on_smf_auth_verify local.success local.response local.http_code:
        local.player = level.pending_auth_player
    
        if (local.success && local.http_code == 200) {
            // Parse JSON response to get member_id and member_name
            // Response format: {"success":true,"member_id":123,"member_name":"PlayerName","guid":"xxx"}
            println ("SMF Auth response: " + local.response)
        
            // Simple JSON parsing for member_id (look for "member_id":NUMBER)
            // In production, use proper JSON parsing if available
            local.member_id = 0
            local.member_name = "Unknown"
        
            // Extract member_id from response
            // TODO: Use proper JSON parsing when available in OpenMOHAA
            // For now, we assume the API returns the member_id in a parseable format
            local.member_id = waitthread global/tracker_common.scr::json_get_int local.response "member_id"
            local.member_name = waitthread global/tracker_common.scr::json_get_string local.response "member_name"
        
            if (local.member_id > 0) {
                // SUCCESS - Store SMF identity on player
                local.player.is_authenticated = 1
                local.player.smf_member_id = local.member_id
                local.player.smf_member_name = local.member_name
                local.player.auth_token = local.player.pending_auth_token
            
                iprintln ("Welcome, " + local.member_name + "! You are now logged in.")
                iprintln "Your stats will be tracked to your forum account."
                println ("SMF Auth SUCCESS: " + local.player.netname + " -> member_id=" + local.member_id)
            
                // HUD Notification: Success
                thread show_hud_notification local.player ("Welcome " + local.member_name + "!") 0.0 1.0 0.0 // Green
            
                // Send login event to API with SMF member_id
                thread send_player_auth_event local.player
            } else {
                local.player.is_authenticated = 0
                iprintln "Login failed: Could not verify token."
                println ("SMF Auth FAIL: No member_id in response")

                // HUD Notification: Fail
                thread show_hud_notification local.player "Login Failed: Invalid Response" 1.0 0.0 0.0 // Red
            }
        } else if (local.http_code == 401 || local.http_code == 403) {
            local.player.is_authenticated = 0
            iprintln "Login failed: Invalid or expired token."
            iprintln "Generate a new token from the forum."
            println ("SMF Auth FAIL: " + local.http_code + " - " + local.response)

            // HUD Notification: Fail
            thread show_hud_notification local.player "Login Failed: Invalid Token" 1.0 0.0 0.0 // Red
        } else {
            local.player.is_authenticated = 0
            iprintln "Login failed: Server error. Try again later."
            println ("SMF Auth ERROR: " + local.http_code + " - " + local.response)

            // HUD Notification: Fail
            thread show_hud_notification local.player "Login Failed: Server Error" 1.0 0.0 0.0 // Red
        }
    
        // Clear pending reference
        level.pending_auth_player = NIL
    end

send_player_auth_event local.player:
        local.payload = global/tracker_common.scr::build_base_payload "player_auth"
        local.payload = local.payload + global/tracker_common.scr::build_player_payload local.player "player"
        local.payload = local.payload + "&smf_member_id=" + local.player.smf_member_id
        local.payload = local.payload + "&smf_member_name=" + local.player.smf_member_name

        thread global/tracker_common.scr::queue_event local.payload
    end

on_auth_verify local.success local.response local.http_code:
    // Legacy callback - redirect to SMF auth
        if (local.success && local.http_code == 200) {
            println ("Legacy auth verified: " + local.response)
            iprintln "Authentication successful!"
        } else {
            println ("Legacy auth failed: " + local.response)
            iprintln "Authentication failed. Check your token."
        }
    end

on_claim_response local.success local.response local.http_code:
        if (local.success && local.http_code == 200) {
            iprintln "Identity claimed! Your stats are now linked."
        } else if (local.http_code == 404) {
            iprintln "Invalid claim code. Try again."
        } else {
            iprintln "Claim failed. Try again later."
        }
    end

on_stats_response local.success local.response local.http_code:
        if (local.success) {
            iprintln "Stats fetched - check console"
            println ("Stats: " + local.response)
        } else {
            iprintln "Could not fetch stats."
        }
    end
